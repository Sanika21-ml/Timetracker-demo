/*! @azure/msal-browser v5.2.0 2026-02-10 */
'use strict';
import { BrowserAuthError } from '../error/BrowserAuthError.mjs';
import { DatabaseStorage } from './DatabaseStorage.mjs';
import { MemoryStorage } from './MemoryStorage.mjs';
import { databaseUnavailable } from '../error/BrowserAuthErrorCodes.mjs';

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * This class allows MSAL to store artifacts asynchronously using the DatabaseStorage IndexedDB wrapper,
 * backed up with the more volatile MemoryStorage object for cases in which IndexedDB may be unavailable.
 */
class AsyncMemoryStorage {
    constructor(logger) {
        this.inMemoryCache = new MemoryStorage();
        this.indexedDBCache = new DatabaseStorage();
        this.logger = logger;
    }
    handleDatabaseAccessError(error, correlationId) {
        if (error instanceof BrowserAuthError &&
            error.errorCode === databaseUnavailable) {
            this.logger.error("1wx7zz", correlationId);
        }
        else {
            throw error;
        }
    }
    /**
     * Get the item matching the given key. Tries in-memory cache first, then in the asynchronous
     * storage object if item isn't found in-memory.
     * @param key
     * @param correlationId
     */
    async getItem(key, correlationId) {
        const item = this.inMemoryCache.getItem(key);
        if (!item) {
            try {
                this.logger.verbose("0naxpl", correlationId);
                return await this.indexedDBCache.getItem(key);
            }
            catch (e) {
                this.handleDatabaseAccessError(e, correlationId);
            }
        }
        return item;
    }
    /**
     * Sets the item in the in-memory cache and then tries to set it in the asynchronous
     * storage object with the given key.
     * @param key
     * @param value
     * @param correlationId
     */
    async setItem(key, value, correlationId) {
        this.inMemoryCache.setItem(key, value);
        try {
            await this.indexedDBCache.setItem(key, value);
        }
        catch (e) {
            this.handleDatabaseAccessError(e, correlationId);
        }
    }
    /**
     * Removes the item matching the key from the in-memory cache, then tries to remove it from the asynchronous storage object.
     * @param key
     * @param correlationId
     */
    async removeItem(key, correlationId) {
        this.inMemoryCache.removeItem(key);
        try {
            await this.indexedDBCache.removeItem(key);
        }
        catch (e) {
            this.handleDatabaseAccessError(e, correlationId);
        }
    }
    /**
     * Get all the keys from the in-memory cache as an iterable array of strings. If no keys are found, query the keys in the
     * asynchronous storage object.
     * @param correlationId
     */
    async getKeys(correlationId) {
        const cacheKeys = this.inMemoryCache.getKeys();
        if (cacheKeys.length === 0) {
            try {
                this.logger.verbose("1iqrbq", correlationId);
                return await this.indexedDBCache.getKeys();
            }
            catch (e) {
                this.handleDatabaseAccessError(e, correlationId);
            }
        }
        return cacheKeys;
    }
    /**
     * Returns true or false if the given key is present in the cache.
     * @param key
     * @param correlationId
     */
    async containsKey(key, correlationId) {
        const containsKey = this.inMemoryCache.containsKey(key);
        if (!containsKey) {
            try {
                this.logger.verbose("03zl2j", correlationId);
                return await this.indexedDBCache.containsKey(key);
            }
            catch (e) {
                this.handleDatabaseAccessError(e, correlationId);
            }
        }
        return containsKey;
    }
    /**
     * Clears in-memory Map
     * @param correlationId
     */
    clearInMemory(correlationId) {
        // InMemory cache is a Map instance, clear is straightforward
        this.logger.verbose("03r21p", correlationId);
        this.inMemoryCache.clear();
        this.logger.verbose("0uksk1", correlationId);
    }
    /**
     * Tries to delete the IndexedDB database
     * @param correlationId
     * @returns
     */
    async clearPersistent(correlationId) {
        try {
            this.logger.verbose("0rdqut", correlationId);
            const dbDeleted = await this.indexedDBCache.deleteDatabase();
            if (dbDeleted) {
                this.logger.verbose("149ouc", correlationId);
            }
            return dbDeleted;
        }
        catch (e) {
            this.handleDatabaseAccessError(e, correlationId);
            return false;
        }
    }
}

export { AsyncMemoryStorage };
//# sourceMappingURL=AsyncMemoryStorage.mjs.map
